var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
import xs from 'xstream';
import { adapt } from '@cycle/run/lib/adapt';
import { RouterSource } from './RouterSource';
import { createPath } from 'history';
/**
 * Wraps main to provide an advanced interface over @cycle/history
 * @public
 * @method routerify
 * @return {main} The augmented main function
 */
function routerify(main, routeMatcher, options) {
    if (typeof main !== 'function') {
        throw new Error('First argument to routerify must be a valid cycle app');
    }
    var opts = __assign({ basename: '/', historyName: 'history', routerName: 'router', omitHistory: true }, options);
    var createHref = function (location) {
        return opts.basename + createPath(location);
    };
    return function (sources) {
        var _a, _b;
        var routerSource = new RouterSource(xs.fromObservable(sources[opts.historyName]).remember(), [], createHref, routeMatcher, opts.routerName);
        var srcs = sources;
        if (opts.omitHistory) {
            delete srcs[opts.historyName];
        }
        var sinks = main(__assign({}, srcs, (_a = {}, _a[opts.routerName] = routerSource, _a)));
        return __assign({}, sinks, (_b = {}, _b[opts.historyName] = adapt(xs.merge(sinks[opts.historyName] && !opts.omitHistory
            ? xs.fromObservable(sinks[opts.historyName])
            : xs.never(), sinks[opts.routerName]
            ? xs.fromObservable(sinks[opts.routerName])
            : xs.never())), _b));
    };
}
export { routerify };
//# sourceMappingURL=routerify.js.map