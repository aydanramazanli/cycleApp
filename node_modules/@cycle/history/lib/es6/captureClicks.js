import xs from 'xstream';
var CLICK_EVENT = typeof document !== 'undefined' && document.ontouchstart
    ? 'touchstart'
    : 'click';
function which(ev) {
    if (typeof window === 'undefined') {
        return false;
    }
    var e = ev || window.event;
    return e.which === null ? e.button : e.which;
}
function sameOrigin(href) {
    if (typeof window === 'undefined') {
        return false;
    }
    return href && href.indexOf(window.location.origin) === 0;
}
function makeClickListener(push) {
    return function clickListener(event) {
        if (which(event) !== 1) {
            return;
        }
        if (event.metaKey || event.ctrlKey || event.shiftKey) {
            return;
        }
        if (event.defaultPrevented) {
            return;
        }
        var element = event.target;
        while (element && element.nodeName !== 'A') {
            element = element.parentNode;
        }
        if (!element || element.nodeName !== 'A') {
            return;
        }
        if (element.hasAttribute('download') ||
            element.getAttribute('rel') === 'external') {
            return;
        }
        if (element.target) {
            return;
        }
        var link = element.getAttribute('href');
        if ((link && link.indexOf('mailto:') > -1) || link.charAt(0) === '#') {
            return;
        }
        if (!sameOrigin(element.href)) {
            return;
        }
        event.preventDefault();
        var pathname = element.pathname, search = element.search, _a = element.hash, hash = _a === void 0 ? '' : _a;
        push(pathname + search + hash);
    };
}
function captureAnchorClicks(push) {
    var listener = makeClickListener(push);
    if (typeof window !== 'undefined') {
        document.addEventListener(CLICK_EVENT, listener, false);
    }
    return function () {
        return document.removeEventListener(CLICK_EVENT, listener);
    };
}
export function captureClicks(historyDriver) {
    return function historyDriverWithClickCapture(sink$) {
        var cleanup;
        var internalSink$ = xs.create({
            start: function () { },
            stop: function () { return typeof cleanup === 'function' && cleanup(); },
        });
        cleanup = captureAnchorClicks(function (pathname) {
            internalSink$._n({ type: 'push', pathname: pathname });
        });
        sink$._add(internalSink$);
        return historyDriver(internalSink$);
    };
}
//# sourceMappingURL=captureClicks.js.map